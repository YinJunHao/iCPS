import requests
from flask import Response
from datetime import timedelta, datetime
from CPSBuilder.modules.socketio.broadcast_job import BroadcastJob
from CPSBuilder.modules.archive.action_management_module import ActionManagementModule
from CPSBuilder.modules.archive.task_management_module import TaskManagementModule
from CPSBuilder.utils.route import *
from CPSBuilder.utils.archive.module_functions import *
from CPSBuilder.utils.db import *

logger = logging.getLogger(__name__)


class ExecutionModule():
    def __init__(self, client):
        self.client = client
        self.job_history = client['job-history']
        self.broadcast = client['job-history']['broadcast']
        self.action_exec = client['action-exec-collection']
        self.error_codes = client['job-history']['error-code']
        self.robot = client['resources']['robot']
        self.hardware = client['resources']['hardware_resources']
        self.software = client['resources']['software_resources']
        self.connection_list = client['resources']['connection_list']
        self.task_management_module = TaskManagementModule(client)
        self.action_management_module = ActionManagementModule(client)

        self.resources_db = client['resources']

        # These are updated when a camera is first assigned to an action and
        # cleared when a complete action has been submitted
        self.camera_ip = None
        self.camera_port = None

    def insert_running_job(self, task, action_list, action_exec_list, user_id):
        """
        Initializes and inserts a record of the job into the job history database with a blank start time for each action. \n
        Params: \n
        task: Task variable that is executed. \n
        action_list: List of action variables that is used in the job. \n
        action_exec_list: List of executors for the action. \n
        user_id: ID of the user who submitted the job. \n
         \n
        Returns: \n
        A tuple in the form (MongoID of inserted Job, JobID generated by the system). \n
        Note: Generated jobID is more legible, but the primary index of the database is still the MongoID for consistency.
        """
        print ('insert job')
        job_id = self.get_job_id(task, user_id)
        # pprint(action_exec_list)
        action_details_list = self.package_action_details_list(action_list, action_exec_list, user_id)
        step_details_list = self.package_step_details_list(action_exec_list)
        post = {
            'job_id': job_id,
            'task': task,
            'state_buffer': [],
            'state_buffer_flag': False,
            'action_details_list': action_details_list,
            'step_details_list': step_details_list,
            'task_status': 'pending',
            'job_submission_timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S").__str__()
            # 'action_exec': action_exec_list,
            # 'user_id': user_id
        }
        res = self.job_history[user_id].insert_one(post)
        return str(res.inserted_id), job_id

    def package_action_details_list(self, action_list, action_exec_list, user_id):
        init_time = ['-'] * len(action_list)
        init_status = ['pending'] * len(action_list)
        action_details_list = []
        for index, action in enumerate(action_list):
            # to get action per task
            action_var = action[0]
            action_exec_tmp = []
            location_id = None   # initialize, because variables that are defined in a python loop only exists in loop
            for action_exec in action_exec_list:
                # to get action details that matches the sequence defined in action_list
                if index == int(action_exec.get('action_seq')):
                    # print(action_exec.get('action'))
                    # pprint(action_exec)
                    for step_seq, step_exec_list in enumerate(action_exec.get('exec_list')):

                        # to get step details per action
                        step_var = None
                        # exec_list = []
                        # for idx, step_exec in enumerate(step_exec_list):
                        #     pprint(step_exec)
                        #     # to get executor details per step
                        #     if step_exec['allow_alternative_exec']:
                        #         alternative_exec = step_exec.get('alternative_exec')
                        #     else:
                        #         alternative_exec = None
                        #     step_var = step_exec.get(
                        #         'step_var', None)
                        #     to_append = {
                        #         "exec_index": idx,
                        #         "preferred_exec": {
                        #             "ID": step_exec.get('ID'),
                        #             "class": step_exec.get('class'),
                        #             "name": step_exec.get('name'),
                        #             "type": step_exec.get('type')
                        #         },
                        #         "alternative_exec": alternative_exec,
                        #         "actual_exec": None,
                        #         "exec_step_status": None,
                        #         "software_id": step_exec.get('software_id'),
                        #         "software_name": step_exec.get('software_name')
                        #     }
                        #     exec_list.append(to_append)
                            # print(step_var)
                        action_exec_tmp_item = {
                            "step_index": step_seq,
                            "step_var": step_var,
                            # todo: shift to a different location START
                            # "exec_list": exec_list,
                            # "step_start": "-",
                            # "step_complete": "-",
                            # "step_status": "pending"
                            # todo: shift to a different location END
                        }
                        action_exec_tmp.append(action_exec_tmp_item)

                    location_id = action_exec.get('location_id')
                    user_id = action_exec.get('user_id')
            action_details = {
                "action_index": index,
                "action_var": action[0],
                "action_sentence": action[1],
                "action_start": init_time[index],
                "action_complete": init_time[index],
                "action_status": init_status[index],
                "action_exec": action_exec_tmp,
                "user_id": user_id,
                "location_id": location_id,
                "total_step_count": self.get_step_count(action_exec_list, action[0]),
                "completed_step_count": 0
            }
            action_details_list.append(action_details)
        return action_details_list

    def package_step_details_list(self, action_exec_list):
        step_details_list = []
        step_index = -1
        for action_exec in action_exec_list:
            for step_seq, step_exec_list in enumerate(action_exec.get('exec_list')):
                # to get step details per action
                step_var = None
                exec_list = []
                for idx, step_exec in enumerate(step_exec_list):
                    pprint(step_exec)
                    # to get executor details per step
                    if step_exec['allow_alternative_exec']:
                        alternative_exec = step_exec.get('alternative_exec')
                    else:
                        alternative_exec = None
                    step_var = step_exec.get(
                        'step_var', None)
                    to_append = {
                        "exec_index": idx,
                        "preferred_exec": {
                            "ID": step_exec.get('ID'),
                            "class": step_exec.get('class'),
                            "name": step_exec.get('name'),
                            "type": step_exec.get('type')
                        },
                        "alternative_exec": alternative_exec,
                        "actual_exec": None,
                        "exec_step_status": None,
                        "software_id": step_exec.get('software_id'),
                        "software_name": step_exec.get('software_name')
                    }
                    exec_list.append(to_append)
                    # print(step_var)
                    step_index += 1
                location_id = action_exec.get('location_id')
                action_exec_tmp_item = {
                    "step_index": step_index,
                    "step_var": step_var,
                    "location_id": location_id,
                    "exec_list": exec_list,
                    "step_start": "-",
                    "step_complete": "-",
                    "step_status": "pending"
                }
                step_details_list.append(action_exec_tmp_item)
        return step_details_list

    def package_single_job(self, job_id, user_id, action_seq, step_seq):
        """
        Package a single job according to the action_seq and step_seq \n
        Returns a list of packaged job details per executor within per step
        For each broadcast
        """
        try:
            job_details = next(
                self.job_history[user_id].find({'job_id': job_id}))
        except StopIteration:
            mes = f'No job {job_id} for user {user_id} does not exist'
            return mes, 500
        action_details = job_details['action_details_list'][action_seq]     # todo: remove this
        step_details = job_details['step_details_list'][step_seq]
        exec_list = step_details['exec_list']
        job_detail_list = []
        for idx, exec_details in enumerate(exec_list):
            post = {
                'job_id': job_id,
                'user_id': user_id,
                'action_seq': action_seq,
                'step_seq': step_seq,
                'step_var': step_details.get('step_var'),
                'exec_index': idx,
                'preferred_exec': exec_details['preferred_exec']['ID'],
                'preferred_exec_details': exec_details['preferred_exec'],
                'alternative_exec': exec_details['alternative_exec'],
                'software_id': exec_details['software_id'],
                'software_name': exec_details['software_name'],
                'location_id': action_details.get('location_id'),   # todo: change to get from step details
                'given_up': False,
                'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S").__str__()
            }
            job_detail_list.append(post)
        return job_detail_list

    def package_job(self, job_id, action_details, action_list, task_var, user_id):
        """
        DO NOT USSEEEEEEEE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        Package all jobs that is registered to the job_history. WARNING: Deprecated
        """
        import warnings
        warnings.warn(
            "method deprecated, please use package_single_job", DeprecationWarning)

        details_out = []
        for action_seq, action_detail in enumerate(action_details):
            camera = False
            # pprint(action_detail)
            cur_action = action_detail.get('action')
            location_id = action_detail.get('location_id')
            for step_seq, step_exec_list in enumerate(action_detail.get('exec_list')):
                for idx, step_exec in enumerate(step_exec_list):
                    cur_step = step_exec.get('step_var')
                    if step_seq - 1 >= 0:
                        prev_step = action_detail.get(
                            'exec_list')[step_seq-1][0].get('step_var')
                        prev_step_done = False
                    else:
                        prev_step = None
                        prev_step_done = True
                    if action_seq - 1 >= 0:
                        prev_action_done = False
                    else:
                        prev_action_done = True
                    software_id = step_exec.get('software_id')
                    software_name = step_exec.get('software_name')
                    executor = step_exec.get('name')
                    post = {
                        'user_id': user_id,
                        'job_id': job_id,
                        'action_seq': action_seq,
                        'step_seq': step_seq,
                        'cur_action': cur_action,
                        'cur_step': cur_step,
                        'prev_step': prev_step,
                        'preferred_executor': executor,
                        'software_id': software_id,
                        'software_name': software_name,
                        'prev_step_done': prev_step_done,
                        'prev_action_done': prev_action_done,
                        'location_id': location_id,
                        'given_up': False,
                        'time_added': datetime.now().__str__()
                    }
                    details_out.append(post)
        return details_out

    def get_step_count(self, action_exec_list, action_var):
        """
        Retrieves the number of stepes for each actions
        """
        for action_exec in action_exec_list:
            if action_exec.get('action') == action_var:
                return len(action_exec.get('exec_list'))
        return None

    def get_max_id(self, db):
        """
        Retrieves the highest numerical job ID in the database.
        """
        id_list = self.get_id_list(db)
        if len(id_list) == 0:
            return 0
        return max(id_list)

    def get_id_list(self, db):
        id_list = []
        for item in db.find():
            try:
                id_list.append(self.get_num_id(item.get('job_id')))
            except:
                pass
        return id_list

    def get_num_id(self, item_id):
        num_id = ''
        for char in item_id:
            # print(char)
            if char.isdigit():
                num_id += char
        # print(num_id)
        return int(num_id)

    def get_job_id(self, task, user_id):
        """
        Gets the new ID for the job that is to be added to the job history.
        """
        words = task.split('_')
        initial = ''
        for word in words:
            initial += word.upper()[0]
        num_id = self.get_max_id(self.job_history[user_id])
        return initial + str(num_id + 1).rjust(5, "0")

    def get_job_detail(self, detail_id, user_id):
        """
        Retrieves the detail for the job history based on the job id
        """
        try:
            out = next(self.job_history[user_id].find({'job_id': detail_id}))
        except Exception as e:
            # print(e)
            out = None
        return out

    def get_job_status(self, user_id):
        """
        Retrieves status for all jobs that a user has submitted
        """
        job_list = self.get_running_job(user_id)
        out = []
        for job in job_list:
            job_id = job.get('job_id')
            task = job.get('task')
            task_status = job.get('task_status')
            task_status_sentence = self.get_error_sentence([task_status])
            timestamp = job.get('job_submission_timestamp')
            # print(timestamp)
            out.append(
                {
                    'job_id': job_id,
                    'task_status': (task, task_status_sentence[0]),
                    'job_submission_timestamp': timestamp,
                }
            )
        return out

    def get_running_job(self, user_id):
        """
        Retrieves all jobs that a user has submitted
        """
        dt = datetime.now() - timedelta(hours=24)
        running_job_curs = self.job_history[user_id].find()
        running_job = []
        for item in running_job_curs:
            running_job.append(item)
        return running_job

    def get_error_sentence(self, status_list):
        """
        Translates error status into readable sentence for display
        """
        out = []
        for status in status_list:
            # print(status)
            curs = self.error_codes.find({'code': status})
            try:
                status_sentence = next(curs)['sentence']
                out.append(status_sentence)
            except Exception as e:
                out.append('Pending')
                # print(status)
                # print('fail')
        return out

    def get_cyber_twin_address(self, executor_name):
        out = None
        curs = self.connection_list.find({'name': executor_name})
        if curs.count() == 1:
            item = next(curs)
            ip, port = item.get('ip'), item.get('port')
            out = f'{ip}:{port}'
        else:
            out = None
        return out

    def get_prev_step_record(self, job_id, user_id):
        try:
            job_details = next(
                self.job_history[user_id].find({'job_id': job_id}))
        except StopIteration:
            logger.error(f"[{job_id}]: {job_id} not found in database.")
            return None, None
        prev_action_seq = job_details.get("process_action_seq", "")
        prev_step_seq = job_details.get("process_step_seq", "")
        return prev_action_seq, prev_step_seq
        
    def post_job_to_board(self, job_id, user_id, action_seq, step_seq):
        """
        Broadcast
        Post packaged job details to broadcast database
        """
        # todo: (this func remains to add broadcast to db, just in case) Add another func to broadcast via socketio
        job_detail_list = self.package_single_job(
            job_id, user_id, action_seq, step_seq)
        for job_detail in job_detail_list:
            self.broadcast.insert_one(job_detail)
        broadcast_job_thread = BroadcastJob(
            self.client,
            job_id=job_id,
            user_id=user_id,
            action_seq=action_seq,
            step_seq=step_seq)
        broadcast_job_thread.start()
        post = {
            "process_action_seq": action_seq,
            "process_step_seq": step_seq
        }
        self.job_history[user_id].update_one(
            {'job_id': job_id}, {'$set': post}, upsert=True)
        mes = f'job: {job_id} action step: {action_seq} and step step: {step_seq} for user {user_id} was inserted successfully at {datetime.now().strftime("%Y-%m-%d %H:%M:%S").__str__()}'
        return mes, 200

    def init_job_execution(self, job_id, user_id):
        """
        Broadcast the first step to initialize the process into the broadcast database
        """
        action_seq = 0
        step_seq = 0

        self.post_job_to_board(job_id, user_id, action_seq, step_seq)
        return action_seq, step_seq

    def assign_job(self, job_details):
        for job_detail in job_details:
            ip_port = self.get_cyber_twin_address(job_detail.get('executor'))
            post = job_detail
            if ip_port is not None:
                headers = {'Content-Type': 'application/json'}
                res = requests.post(
                    f'http://{ip_port}/api/cyber-twin/accept-job/insert-new-job', data=json.dumps(post), headers=headers)
                print(res.content.decode('utf-8'))
            else:
                print('no compatible cyber twin found')
                # pprint(job_detail)
        # print(requests.get('http://127.0.0.1:9999/api/test_connection').content.decode('utf-8'))

    def add_cyber_twin(self, details):
        collection = {"hardware": "hardware_resources", "robot": "robot", "human": "human_resources"}
        sub_resources_db = self.resources_db[collection[details["class"]]]
        ip, port, resource_name = details.get(
            'ip'), details.get('port'), details.get('name')
        if (ip is not None) and (port is not None):
            if self.connection_list.find({'ip': ip, 'port': port}).count() == 0:
                if self.connection_list.find({'name': resource_name}).count() == 0:
                    self.connection_list.insert_one(details)
                    res = f'{ip}:{port} registered for {resource_name}'
                    status = 200
                else:
                    self.connection_list.update_one({'name': resource_name}, {
                        '$set': {
                            'ip': ip,
                            'port': port
                        }
                    }, upsert=False)
                    res = f'{resource_name} IP address updated to {ip}:{port}'
                    status = 200
                self.connection_list.update_one({'name': resource_name, 'ip': ip, 'port': port}, {
                                                '$set': {'status': 'online'}})
                sub_resources_db.update_one(
                    {'ID': resource_name},
                    {'$set': {'availability': '1'}}, upsert=True)
                print(f"{ip}:{port} online")
            else:
                if resource_name == next(self.connection_list.find({'ip': ip, 'port': port}))['name']:
                    self.connection_list.update_one({'name': resource_name, 'ip': ip, 'port': port}, {
                                                    '$set': {'status': 'online'}})
                    sub_resources_db.update_one(
                        {'ID': resource_name},
                        {'$set': {'availability': '1'}}, upsert=True)
                    res = f'{resource_name} at {ip}:{port} is connected'
                    status = 200
                else:
                    res = f'{ip}:{port} is already registered to a different cyber twin'
                    status = 404
        else:
            res = 'invalid ip and/or port'
            status = 404
        logger.info(res)
        return Response(res, status)

    def broadcast_next_task(self, job_id, user_id, action_seq, step_seq):
        connections = print_collection(
            self.connection_list, no_objectid=True, print_out=False)
        for connection in connections:
            ip = connection.get('ip')
            port = connection.get('port')
            try:
                url = f'http://{ip}:{port}/api/test_connection'
                res = requests.get(url).content.decode('utf-8')
                if res == "pong":
                    out = f'{ip}:{port} received broadcast'
            except:
                out = f'{ip}:{port} is not available'
            # print(out)
        print('broadcast next step available for manufacturing')
        self.package_single_job(job_id, user_id, action_seq, step_seq)
        return

    # def send_new_job(job_id, action_seq, step_seq):
    #     print('new thread started')
    #     print('update db')
    #     execution_module.broadcast_next_task(job_id, action_seq, step_seq)
    #     print('broadcast next step available for manufacturing')

    def update_job_history(self, user_id, job_details, new_info):
        query = job_details
        new_info = {"$set": new_info}
        db = self.job_history[user_id]
        db.update_one(query, new_info, upsert=False)

    def fetch_action_detail_list(self, user_id, job_details):
        query = job_details
        db = self.job_history[user_id]
        result = db.find(query, {"_id": 0})
        print(f'query is {query}, results has {result.count()}')
        out = []
        for item in result:
            # print(item)
            out.append(item)
        # pprint(out)
        logger.info(
            f"found {len(out)} info for job {job_details.get('job_id')} and user {user_id}.")
        return out
